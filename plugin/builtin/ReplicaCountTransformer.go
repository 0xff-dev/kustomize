// Code generated by pluginator on ReplicaCountTransformer; DO NOT EDIT.
package builtin

import (
	"fmt"

	"sigs.k8s.io/kustomize/pkg/ifc"
	"sigs.k8s.io/kustomize/pkg/resid"
	"sigs.k8s.io/kustomize/pkg/resmap"
	"sigs.k8s.io/kustomize/pkg/types"
	"sigs.k8s.io/yaml"
)

const (
	fldReplica = "replicas"
	fldSpec    = "spec"
)

// Find matching replicas declarations and replace the count.
// Eases the kustomization configuration of replica changes.
type ReplicaCountTransformerPlugin struct {
	Replica types.Replica `json:"replica,omitempty" yaml:"replica,omitempty"`
}

func NewReplicaCountTransformerPlugin() *ReplicaCountTransformerPlugin {
	return &ReplicaCountTransformerPlugin{}
}

func (p *ReplicaCountTransformerPlugin) Config(
	ldr ifc.Loader, rf *resmap.Factory, c []byte) (err error) {

	p.Replica = types.Replica{}
	return yaml.Unmarshal(c, p)
}

func (p *ReplicaCountTransformerPlugin) Transform(m resmap.ResMap) error {
	matcher := func(r resid.ResId) bool {
		return r.ItemId.Name == p.Replica.Name
	}

	for _, id := range m.GetMatchingIds(matcher) {
		kMap := m.GetById(id).Map()

		specInterface, ok := kMap[fldSpec]
		if !ok {
			return fmt.Errorf("object %s missing field %s, cannot update %s",
				p.Replica.Name, fldSpec, fldReplica)
		}

		if spec, ok := specInterface.(map[string]interface{}); ok {
			spec[fldReplica] = p.Replica.Count
			kMap[fldSpec] = spec
		} else {
			return fmt.Errorf("object %s has a malformed %s", p.Replica.Name, fldSpec)
		}
	}

	return nil
}
